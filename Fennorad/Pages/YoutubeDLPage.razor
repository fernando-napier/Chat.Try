@page "/youtube"
@using System.Diagnostics
@using System.Text
@using Blazor.DownloadFileFast.Interfaces
@using System.Text.RegularExpressions
@using Fennorad.Models
@using YoutubeDLSharp
@using YoutubeDLSharp.Options
@using Google.Apis.Services
@using Google.Apis.YouTube.v3
@inject IJSRuntime JsRuntime
@inject YouTubeService YoutubeService


<div class="container">
    <div class="row center-stuff">
        <div class="col-12 col-md-10">
            <h2>YoutubeDL</h2>
            <p>This is an experimental page where users are allowed to download mp3s or mp4s of youtube videos.</p>
            <hr />
        </div>
    </div>
    <div class="row center-stuff">
        <div class="col-12 col-md-8" style="margin-bottom: 10px;">
            <input disabled=@IsDownloadActive @bind=SearchQuery type="text" style="width: 100%;" placeholder="input search term">  
        </div>
        <div class="col-3 offset-9 col-md-1 offset-md-0">
            <button class="float-right" disabled=@IsDownloadActive @onclick="SearchForVideos">Search</button>
        </div>
    </div>

@if (Videos.Any())
{
    <div class="row center-stuff">
        @foreach (var video in Videos)
        {

             <div class="col-12 col-md-3 offset-0 offset-md-1" style="margin-bottom: 10px; margin-top: 10px;">
                    <div class="center-stuff embed-responsive embed-responsive-16by9">
                    <iframe class="embed-responsive-item" src="https://www.youtube.com/embed/@video.VideoId?rel=0" allowfullscreen></iframe>
                </div>
                <button disabled=@IsDownloadActive @onclick="(() => DownloadVideo(video.VideoId))">Download Video</button>
                    <button disabled=@IsDownloadActive @onclick="(() => DownloadAudio(video.VideoId))">Download Audio</button>
            </div>
        }
    </div>
    
}


<br />
@if (DownloadProgress.Any())
{
    <div class="row center-stuff">
        <div class="col-12 col-md-9 bg-secondary progress-update">
            @for (int i = DownloadProgress.Count - 1; i >= 0; i--)
            {
                <p>@DownloadProgress.ElementAt(i)</p>
            }
        </div>
    </div>
}
@if (DownloadComplete && DownloadSuccess)
{
    <div class="row center-stuff">
        <div class="col-12 col-md-9 bg-success  progress-complete">
            <p>Processing is complete! Now downloading to your browser. </p>
        </div>
    </div>
}
@if (DownloadComplete && !DownloadSuccess)
{
    <div class="row center-stuff">
        <div class="col-12 col-md-9 bg-danger  progress-complete">
            <p>Processing failed! See logs for details. </p>
        </div>
    </div>
}
</div>

<style>
    .float-right {
        float: right;
    }

    .center-stuff {
        justify-content: space-evenly;
        align-content: space-evenly;
    }

    .container {
        justify-content: space-evenly;
        align-content: space-evenly;
    }

    .progress-complete {
        margin-top: 20px;
    }

    .progress-update {
        margin-top: 20px;
        max-height: 200px;
        overflow: auto;
        display: flex!important;
        flex-direction: column-reverse;
    }
    .yt-float-parent-element {
        width: 80%;
        display: inline-block;
    }

    .yt-float-child-element-left  {
        float: left;
        width: 70%;
    }

    .yt-float-child-element-right {
        float: right;
        width: 100px;
    }
    
</style>

@code {
    [Inject]
    public IBlazorDownloadFileService BlazorDownloadFileService { get; set; }

    [Inject]
    public Configuration Config { get; set; }

    private List<YoutubeVideo> Videos { get; set; } = new List<YoutubeVideo>();

    private bool DownloadSuccess = false;
    private bool DownloadComplete = false;
    private bool IsDownloadActive = false;
    private string SearchQuery { get; set; }
    private List<string> DownloadProgress = new List<string>();
    private Regex regex = new Regex(@"^((?:https?:)?\/\/)?((?:www|m)\.)?((?:youtube(-nocookie)?\.com|youtu.be))(\/(?:[\w\-]+\?v=|embed\/|v\/)?)([\w\-]+)(\S+)?$", RegexOptions.Compiled);

    private async Task SearchForVideos()
    {
        if (!string.IsNullOrWhiteSpace(SearchQuery))
        {
            Videos = new List<YoutubeVideo>();
            var searchListRequest = YoutubeService.Search.List("snippet");
            searchListRequest.Q = SearchQuery;
            searchListRequest.Type = "video";
            searchListRequest.Order = SearchResource.ListRequest.OrderEnum.Relevance;
            searchListRequest.MaxResults = 9;

            var searchListResponse = await searchListRequest.ExecuteAsync();
            Videos.AddRange(searchListResponse.Items.Select(video => new YoutubeVideo
                {
                    Thumbnail = video.Snippet.Thumbnails.High.Url,
                    Title = video.Snippet.Title,
                    VideoId = video.Id.VideoId,
                }));
        }

    }

    private async Task DownloadVideo(string videoId)
    {
        await Download(videoId);
    }

    private async Task DownloadAudio(string videoId)
    {
        await Download(videoId, true);

    }

    private async Task Download(string videoId, bool mp3Flag = false)
    {
        var youtubeUrl = $"https://www.youtube.com/watch?v={videoId}";
        IsDownloadActive = true;
        DownloadSuccess = false;
        DownloadComplete = false;
        DownloadProgress = new List<string>();
        StateHasChanged();
        var filename = mp3Flag ? $"{Guid.NewGuid()}.mp3" : $"{Guid.NewGuid()}.mp4";


        if (string.IsNullOrEmpty(youtubeUrl) || !regex.IsMatch(youtubeUrl))
        {
            await JsRuntime.InvokeVoidAsync("alert", "Not a valid youtube url!");
            IsDownloadActive = false;
            StateHasChanged();
            return;
        }

        DownloadProgress.Add("Setting up process...");
        StateHasChanged();

        await Task.Delay(200);
        await JsRuntime.InvokeVoidAsync("scrollWindowToBottom");

        try
        {
            var ytdlProc = new YoutubeDLProcess();
            ytdlProc.PythonPath = Config.PythonPath;
            ytdlProc.ExecutablePath = Config.YoutubeDLPath;
            // capture the standard output and error output
            ytdlProc.OutputReceived += async (o, e) =>
            {
                if (!String.IsNullOrEmpty(e.Data))
                {
                    var data = e.Data.Replace("[download]", "[Processing]");
                    DownloadProgress.Add(data);
                }
                await InvokeAsync(() =>
                {
                    StateHasChanged();
                });
            };
            ytdlProc.ErrorReceived += async (o, e) =>
            {
                if (!String.IsNullOrEmpty(e.Data))
                {
                    DownloadProgress.Add(e.Data);
                }
                await InvokeAsync(() =>
                {
                    StateHasChanged();
                });
            };
            var options = new OptionSet()
                {
                    Output = filename,
                    MaxFilesize = "20.0m",
                };

            if (mp3Flag)
            {
                options.ExtractAudio = mp3Flag;
                options.AudioFormat = AudioConversionFormat.Mp3;
            }

            // start running
            string[] urls = new[] { youtubeUrl };
            await ytdlProc.RunAsync(urls, options);


            var fileExists = File.Exists(filename);
            if (fileExists)
            {
                await BlazorDownloadFileService.DownloadFileAsync(mp3Flag ? "download.mp3" : "download.mp4", File.ReadAllBytes(filename));
                File.Delete(filename);
                DownloadSuccess = true;
            }
            else
            {
                DownloadProgress.Add("Download file does not exist");
                DownloadSuccess = false;
            }

        }
        catch (Exception ex)
        {
            await JsRuntime.InvokeVoidAsync("alert", $"Youtube download failed, try again. {ex.Message}");
            DownloadProgress.Add(ex.Message);
            File.Delete(filename);
        }

        IsDownloadActive = false;
        DownloadComplete = true;
        StateHasChanged();

        await Task.Delay(200);
        await JsRuntime.InvokeVoidAsync("scrollWindowToBottom");
    }
}